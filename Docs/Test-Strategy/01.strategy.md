


## Test Approach and Methodologies
### Functional Testing

The goal of utilizing numerous testing methodologies in your development process is to make sure your software can successfully operate in multiple environments and across different platforms. These can typically be broken down between functional and non-functional testing. Functional testing involves testing the application against the business requirements. It incorporates all test types designed to guarantee each part of a piece of software behaves as expected by using uses cases provided by the design team or business analyst. These testing methods are usually conducted in order and include:

1. Unit testing:	    ---> dev ownership
2. componant testing 	---> dev ownership
3. Integration Testing  ---> dev/test ownership
4. System testing       ---> test ownership
5. Acceptance testing	---> test ownership?

### Non-functional Testing

1. Performance testing
2. Security testing
3. Usability testing
4. Compatibility testing

The key to releasing high quality software that can be easily adopted by your end users is to build a robust testing framework that implements both functional and non-functional software testing methodologies.



Performance testing is a non-functional testing technique used to determine how an application will behave under various conditions. The goal is to test its responsiveness and stability in real user situations. Performance testing can be broken down into four types:

    Load testing is the process of putting increasing amounts of simulated demand on your software, application, or website to verify whether or not it can handle what it’s designed to handle.
    Stress testing takes this a step further and is used to gauge how your software will respond at or beyond its peak load. The goal of stress testing is to overload the application on purpose until it breaks by applying both realistic and unrealistic load scenarios. With stress testing, you’ll be able to find the failure point of your piece of software.
    Endurance testing, also known as soak testing, is used to analyze the behavior of an application under a specific amount of simulated load over longer amounts of time. The goal is to understand how your system will behave under sustained use, making it a longer process than load or stress testing (which are designed to end after a few hours). A critical piece of endurance testing is that it helps uncover memory leaks.
    Spike testing is a type of load test used to determine how your software will respond to substantially larger bursts of concurrent user or system activity over varying amounts of time. Ideally, this will help you understand what will happen when the load is suddenly and drastically increased.

Security Testing

With the rise of cloud-based testing platforms and cyber attacks, there is a growing concern and need for the security of data being used and stored in software. Security testing is a non-functional software testing technique used to determine if the information and data in a system is protected. The goal is to purposefully find loopholes and security risks in the system that could result in unauthorized access to or the loss of information by probing the application for weaknesses. There are multiple types of this testing method, each of which aimed at verifying six basic principles of security:

    Integrity
    Confidentiality
    Authentication
    Authorization
    Availability
    Non-repudiation

Usability Testing

Usability testing is a testing method that measures an application’s ease-of-use from the end-user perspective and is often performed during the system or acceptance testing stages. The goal is to determine whether or not the visible design and aesthetics of an application meet the intended workflow for various processes, such as logging into an application. Usability testing is a great way for teams to review separate functions, or the system as a whole, is intuitive to use.
Compatibility Testing

Compatibility testing is used to gauge how an application or piece of software will work in different environments. It is used to check that your product is compatible with multiple operating systems, platforms, browsers, or resolution configurations. The goal is to ensure that your software’s functionality is consistently supported across any environment you expect your end users to be using.
Testing With TestComplete

TestComplete is our robust automated GUI testing tool that excels in compatibility and integration testing. It helps QA teams create and run tests across desktop, mobile, and web applications – enabling testing professionals to speed up delivery cycles and improve software quality. Testcomplete comes with built-in support for various test environments, integrations to performance testing tools, as well as support for developer friendly SCMs, allowing you to seamlessness integrate it into your development process. Using TestComplete will enable you to build a robust testing framework that utilizes the broad spectrum of available software testing methodologies.



## Test process

Alias Number project is based on a full life cycle testing approach where testing cannot be defined as a separate phase. It is an iterative and integral part of software development (SDLC).
	
	1. As a precondition, the sprint stories, should be exist (definition of ready).
	2. Once the definition of ready is accomplished, the development team will start with the development of the user story and at the same time, the qualification team will start the test design of the user story.
	3. After the dev. team finished the user story, the test environment should be ready for the qualification engineer to validate the expected artifacts of the project.
	4. Qualification will then start to execute the user story test cases on the test environment and report bugs.
	5. After qualification finishes the test execution and bug reporting, the user story is challenged against the Done Definition and then judged to be “Accepted and released” or “Rejected and returned to Backlog”.
	6. After the demo, the development team deploy on the preproduction environment and the qualification perform smoke/regression testing on the preproduction environment
	7. These steps will be run at each sprint.

![](test_process.png)




### Defect Management Process

The purpose of the defect management process is to implement the processes to manage the tracking and fixing of defects that are found during testing and perform root cause analysis.

### Severity Level Definitions:

<table>
	<thead>
		<tr>
			<th>
				<strong>Severity level</strong>
			</th>
			<th>
				<strong>Description</strong>
			</th>
			<th>
				<strong>Example</strong>
			</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Critical</td>
			<td>Crashes, no further processing is possible.</td>
			<td>Critical to application such as availability, results, functionality, performance or usability</td>
		</tr>
		<tr>
			<td>High</td>
			<td>Unable to proceed with selected function or dependents.</td>
			<td>Unavailability of key feature, incorrect results ,performance or usability</td>
		</tr>
		<tr>
			<td>Medium</td>
			<td>Restricted function capability, however processing can continue</td>
			<td>Unavailable Non-key feature, incorrect results, performance or usability</td>
		</tr>
		<tr>
			<td>Low</td>
			<td>Minor cosmetic change</td>
			<td>Usability error screen or report errors that do not materially affect quality, correctness of function or results</td>
		</tr>
	</tbody>
</table>


13. Test Environment and Tools
    - robot framework
    - lighthouse
    - locust
    - zap-cli
14. Test Schedule and Timelines
15. Test Reporting and Review

