


4. Test Approach and Methodologies


Software testing methodologies are the various strategies or approaches used to test an application to ensure it behaves and looks as expected. These encompass everything from front to back-end testing, including unit and system testing.
Functional vs. Non-functional Testing

The goal of utilizing numerous testing methodologies in your development process is to make sure your software can successfully operate in multiple environments and across different platforms. These can typically be broken down between functional and non-functional testing. Functional testing involves testing the application against the business requirements. It incorporates all test types designed to guarantee each part of a piece of software behaves as expected by using uses cases provided by the design team or business analyst. These testing methods are usually conducted in order and include:

    Unit testing
    Integration testing
    System testing
    Acceptance testing

Non-functional testing methods incorporate all test types focused on the operational aspects of a piece of software. These include:

    Performance testing
    Security testing
    Usability testing
    Compatibility testing

The key to releasing high quality software that can be easily adopted by your end users is to build a robust testing framework that implements both functional and non-functional software testing methodologies.
Unit Testing

Unit testing is the first level of testing and is often performed by the developers themselves. It is the process of ensuring individual components of a piece of software at the code level are functional and work as they were designed to. Developers in a test-driven environment will typically write and run the tests prior to the software or feature being passed over to the test team. Unit testing can be conducted manually, but automating the process will speed up delivery cycles and expand test coverage. Unit testing will also make debugging easier because finding issues earlier means they take less time to fix than if they were discovered later in the testing process. TestLeft is a tool that allows advanced testers and developers to shift left with the fastest test automation tool embedded in any IDE.

Start Shifting Left and Automate now with TestLeft

Integration Testing

After each unit is thoroughly tested, it is integrated with other units to create modules or components that are designed to perform specific tasks or activities. These are then tested as group through integration testing to ensure whole segments of an application behave as expected (i.e, the interactions between units are seamless). These tests are often framed by user scenarios, such as logging into an application or opening files. Integrated tests can be conducted by either developers or independent testers and are usually comprised of a combination of automated functional and manual tests.
System Testing

System testing is a black box testing method used to evaluate the completed and integrated system, as a whole, to ensure it meets specified requirements. The functionality of the software is tested from end-to-end and is typically conducted by a separate testing team than the development team before the product is pushed into production.
Acceptance Testing

Acceptance testing is the last phase of functional testing and is used to assess whether or not the final piece of software is ready for delivery. It involves ensuring that the product is in compliance with all of the original business criteria and that it meets the end user’s needs. This requires the product be tested both internally and externally, meaning you’ll need to get it into the hands of your end users for beta testing along with those of your QA team. Beta testing is key to getting real feedback from potential customers and can address any final usability concerns.
Performance Testing

Performance testing is a non-functional testing technique used to determine how an application will behave under various conditions. The goal is to test its responsiveness and stability in real user situations. Performance testing can be broken down into four types:

    Load testing is the process of putting increasing amounts of simulated demand on your software, application, or website to verify whether or not it can handle what it’s designed to handle.
    Stress testing takes this a step further and is used to gauge how your software will respond at or beyond its peak load. The goal of stress testing is to overload the application on purpose until it breaks by applying both realistic and unrealistic load scenarios. With stress testing, you’ll be able to find the failure point of your piece of software.
    Endurance testing, also known as soak testing, is used to analyze the behavior of an application under a specific amount of simulated load over longer amounts of time. The goal is to understand how your system will behave under sustained use, making it a longer process than load or stress testing (which are designed to end after a few hours). A critical piece of endurance testing is that it helps uncover memory leaks.
    Spike testing is a type of load test used to determine how your software will respond to substantially larger bursts of concurrent user or system activity over varying amounts of time. Ideally, this will help you understand what will happen when the load is suddenly and drastically increased.

Security Testing

With the rise of cloud-based testing platforms and cyber attacks, there is a growing concern and need for the security of data being used and stored in software. Security testing is a non-functional software testing technique used to determine if the information and data in a system is protected. The goal is to purposefully find loopholes and security risks in the system that could result in unauthorized access to or the loss of information by probing the application for weaknesses. There are multiple types of this testing method, each of which aimed at verifying six basic principles of security:

    Integrity
    Confidentiality
    Authentication
    Authorization
    Availability
    Non-repudiation

Usability Testing

Usability testing is a testing method that measures an application’s ease-of-use from the end-user perspective and is often performed during the system or acceptance testing stages. The goal is to determine whether or not the visible design and aesthetics of an application meet the intended workflow for various processes, such as logging into an application. Usability testing is a great way for teams to review separate functions, or the system as a whole, is intuitive to use.
Compatibility Testing

Compatibility testing is used to gauge how an application or piece of software will work in different environments. It is used to check that your product is compatible with multiple operating systems, platforms, browsers, or resolution configurations. The goal is to ensure that your software’s functionality is consistently supported across any environment you expect your end users to be using.
Testing With TestComplete

TestComplete is our robust automated GUI testing tool that excels in compatibility and integration testing. It helps QA teams create and run tests across desktop, mobile, and web applications – enabling testing professionals to speed up delivery cycles and improve software quality. Testcomplete comes with built-in support for various test environments, integrations to performance testing tools, as well as support for developer friendly SCMs, allowing you to seamlessness integrate it into your development process. Using TestComplete will enable you to build a robust testing framework that utilizes the broad spectrum of available software testing methodologies.



## Test process

Alias Number project is based on a full life cycle testing approach where testing cannot be defined as a separate phase. It is an iterative and integral part of software development (SDLC).
	
	1. As a precondition, the sprint stories, should be exist (definition of ready).
	2. Once the definition of ready is accomplished, the development team will start with the development of the user story and at the same time, the qualification team will start the test design of the user story.
	3. After the dev. team finished the user story, the test environment should be ready for the qualification engineer to validate the expected artifacts of the project.
	4. Qualification will then start to execute the user story test cases on the test environment and report bugs.
	5. After qualification finishes the test execution and bug reporting, the user story is challenged against the Done Definition and then judged to be “Accepted and released” or “Rejected and returned to Backlog”.
	6. After the demo, the development team deploy on the preproduction environment and the qualification perform smoke/regression testing on the preproduction environment
	7. These steps will be run at each sprint.

![](test_process.png)




### Defect Management Process

The purpose of the defect management process is to implement the processes to manage the tracking and fixing of defects that are found during testing and perform root cause analysis.

### Severity Level Definitions:

<table>
	<thead>
		<tr>
			<th>
				<strong>Severity level</strong>
			</th>
			<th>
				<strong>Description</strong>
			</th>
			<th>
				<strong>Example</strong>
			</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Critical</td>
			<td>Crashes, no further processing is possible.</td>
			<td>Critical to application such as availability, results, functionality, performance or usability</td>
		</tr>
		<tr>
			<td>High</td>
			<td>Unable to proceed with selected function or dependents.</td>
			<td>Unavailability of key feature, incorrect results ,performance or usability</td>
		</tr>
		<tr>
			<td>Medium</td>
			<td>Restricted function capability, however processing can continue</td>
			<td>Unavailable Non-key feature, incorrect results, performance or usability</td>
		</tr>
		<tr>
			<td>Low</td>
			<td>Minor cosmetic change</td>
			<td>Usability error screen or report errors that do not materially affect quality, correctness of function or results</td>
		</tr>
	</tbody>
</table>


13. Test Environment and Tools
    - robot framework
    - lighthouse
    - locust
    - zap-cli
14. Test Schedule and Timelines
15. Test Reporting and Review

